"""This module implements steps for evaluation of XLNER pipeline"""

import evaluate
from datasets import Dataset, DatasetDict


class IntrinsicEvaluation:
    """Intrinsic evaluator computes SeqEval metrics for generated by XLNER
    labeling compared to ground truth labels for the real NER dataset"""

    def __init__(
        self,
        orig_column: str = "ner_tags",
        gen_column: str = "gen_ner_tags",
        log_to_wandb: bool = True,
        batch_size: int = 1000,
        labels_to_ignore: list[str] | None = None,
    ) -> None:
        super().__init__()
        self.orig_column = orig_column
        self.gen_column = gen_column
        self.log_to_wandb = log_to_wandb
        self.labels_to_ignore = labels_to_ignore
        self.batch_size = batch_size

    def __call__(self, ds: Dataset) -> Dataset:
        if isinstance(ds, DatasetDict):
            split = next(iter(ds.keys()))
            label_list = ds[split].features[self.orig_column].feature.names
        else:
            label_list = ds.features[self.orig_column].feature.names

        # Make all to be ignored labels equal to O
        if self.labels_to_ignore is not None:
            label_list = [
                label if label not in self._labels_to_ignore else "O"
                for label in label_list
            ]

        metric = evaluate.load("seqeval")

        def accumulate_metric(refs, preds):
            ref_labels = [[label_list[tag] for tag in gt] for gt in refs]
            pred_labels = [[label_list[tag] for tag in pred] for pred in preds]
            metric.add_batch(references=ref_labels, predictions=pred_labels)

        ds.map(
            accumulate_metric,
            input_columns=[self.orig_column, self.gen_column],
            batched=True,
            batch_size=self.batch_size,
        )

        results = metric.compute()
        print(results)

        if self.log_to_wandb:
            import wandb

            for gkey, gvalue in results.items():
                if isinstance(gvalue, dict):
                    for key, value in gvalue.items():
                        wandb.run.summary[f"{gkey}_{key}"] = value
                else:
                    wandb.run.summary[gkey] = gvalue

        return ds
